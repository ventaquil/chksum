use super::block::{Block, BLOCK_LENGTH_BYTES};

#[rustfmt::skip]
const PADDING: [u8; BLOCK_LENGTH_BYTES] = [
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

#[derive(Debug, Eq, PartialEq)]
pub(super) enum Padding {
    Single(Block),
    Double(Block, Block),
}

impl From<Block> for Padding {
    fn from(block: Block) -> Self {
        Self::Single(block)
    }
}

impl From<(Block, Block)> for Padding {
    fn from(blocks: (Block, Block)) -> Self {
        Self::Double(blocks.0, blocks.1)
    }
}

impl From<[u8; BLOCK_LENGTH_BYTES]> for Padding {
    fn from(block: [u8; BLOCK_LENGTH_BYTES]) -> Self {
        let block: Block = block.into();
        Self::from(block)
    }
}

impl From<([u8; BLOCK_LENGTH_BYTES], [u8; BLOCK_LENGTH_BYTES])> for Padding {
    fn from(blocks: ([u8; BLOCK_LENGTH_BYTES], [u8; BLOCK_LENGTH_BYTES])) -> Self {
        let blocks: (Block, Block) = (blocks.0.into(), blocks.1.into());
        Self::from(blocks)
    }
}

pub(super) fn pad(block: Block, counter: usize) -> Padding {
    #[rustfmt::skip]
    let length: [u8; BLOCK_LENGTH_BYTES] = {
        let length = counter as u64;
        let length = length * 8; // convert byte-length into bits-length
        let length = length.to_le_bytes();
        [
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00, 
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00, 
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00, 
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00, 
                 0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,      0x00,
            length[0], length[1], length[2], length[3], length[4], length[5], length[6], length[7],
        ]
    };
    let counter = counter % BLOCK_LENGTH_BYTES;
    let padding: Block = PADDING.into();
    if counter + 1 + 8 <= BLOCK_LENGTH_BYTES {
        let padding = padding >> counter;
        let block = block | padding | length;
        block.into()
    } else if counter < BLOCK_LENGTH_BYTES {
        // counter + 1 <= BLOCK_LENGTH_BYTES
        let padding = padding >> counter;
        let block = block | padding;
        let length: Block = length.into();
        (block, length).into()
    } else {
        (block, padding | length).into()
    }
}

#[cfg(test)]
mod tests {
    use super::{pad, Padding};

    #[test]
    fn test_empty() {
        assert_eq!(
            pad(
                [
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ]
                .into(),
                0x00
            ),
            Padding::Single(
                [
                    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ]
                .into()
            )
        );
    }

    #[test]
    fn test_single_block() {
        assert_eq!(
            pad(
                [
                    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ]
                .into(),
                0x08
            ),
            Padding::Single(
                [
                    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                ]
                .into()
            )
        );
    }

    // #[test]
    // fn test_double_block() {
    //     assert_eq!(
    //         pad(
    //             [
    //                 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //             ]
    //             .into(),
    //             0x08
    //         ),
    //         Padding::Single(
    //             [
    //                 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    //             ]
    //             .into()
    //         )
    //     );
    // }
}
